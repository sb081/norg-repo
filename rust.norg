@document.meta
title: rust
description: 
authors: max
categories: 
created: 2022-03-22
version: 0.0.11
@end

= TOC

* Programming in Rust
  Rust is a compiled language.
  You can send the executables to other persons and they can execute it without the need to have rust installed.

** Hello world
   @code rust
   fn main() {
     println!("Hello World!");
   }
   @end

* Syntax
** General
   At the end of every statement you have to put a semicolon `;`.

** Comments
   You do comments with `//` at the beginning of a line.

** Crates
   Crates in Rust are like libraries in other programming languages.
   They can are part of packages and contain modules.
   Inside of the modules there are items which you can access.
   You have to add external crates to your /cargo.toml/ file.
   This can looks like this (example for `rand` crate): `rand = "0.8.3"`.


   There are two ways to use the items from a crate:
   You can always access the crate and the module directly like this:
   @code rust
   crate::module::item();
   crate::module::another_item();
   @end

   You can also bring the module into the scope of the file and access items with the module only later on like this:
   @code rust
   use crate::module;

   module::item();
   module::another_item();
   @end

** Printing
   You can use the `println` macro to output text (see {# Hello World}[hello world]).

*** Placeholders
    You can use the `{}` placeholder to put things into output strings.
    > Think of `{}` as little crab pincers that hold a value in place.
    All the arguments after the output string will be placed where the placeholders are:
    @code rust
    let x = 5;
    let y = 10;

    println!("x = {} and y = {}", x, y); // output: x = 5 and y = 10
    @end

** Variables
   You create variables with `let` for example like this:
   @code rust
   let apples = 5;
   @end

   Most types have a module where you can call functions to do things. For example {# Strings}[String].
   The most of these modules have a `new()` function to create a new variable for that type.

*** Mutability
    By default variables are immutable.
    You can make a variable mutable by putting `mut` before it's name.

    Immutable variables can't be changed after they've been given a value.
    If you try to change the value of an immutable variable you get an error like this:
    `cannot assign twice to immutable variable`.

*** Constants
    Constants are a special type of immutable variables.
    You create them with the `const` keyword instead of `let`.
    You always have to annotate the type.
    The value of a constant can only be a constant value, not one that get calculated at runtime.
    That means it can't be the value of another variable. But it can be another constant.
    You should name constant with all uppercase letters and underscores between words.

    @code rust
    let x = 6;
    // const MY_CONSTANT = x; // would be invalid
    const MY_CONSTANT: u32 = 6;
    const ANOTHER_CONSTANT: u8 = MY_CONSTANT;
    @end

*** Shadowing
    If you use `let` again with an already existing (immutable) variable you'll overwrite it.
    With that you "shadow the existing variable".

**** Differences to mutable variables
     With shadowing you can change the data type of a variable. If you assign a different type to a mutable variable you get an error.
     After changing a variable with shadowing it's immutable again.
     ---
    This is useful so you don't have to come up with that many variable names.
    For example if you get a user input it is a string.
    If you want to get it as a number you'd have to create a new variable if you wouldn't use shadowing.
    That would require you to create e.g. `input_str` and `input_num`.
    With shadowing you can just create one variable `input`.

**** Scope
     If you shadow a variable it's only shadowed in the current scope.
     If you leave the scope it will have the variable before you shadowed it again.
     @code rust
     let x = 5;
     let x = x + 1;
     {
       let x = x * 2;
       println!("The value of x in the inner scope is: {}", x); // x is 12
     }
     println!("The value of x is: {}", x); // x is 6 again
     @end


** Data Types
   Rust always needs to know the type of variables.
   In many cases it can get it based on the value.
   When multiple types are possible (e.g. when converting a string to a numeric type with `parse`) you need to annotate the type like this:
   @code rust
   let input: u32 = "42".parse().expect("Not a number!");
   @end

   The compound and the scalar types following here can be stored on the stack because they have a fixed size.

*** Scalar Types
    Scalar types represent single values.
    There are for types.
**** Integer Types
     You can have unsigned and signed integer types.
     @table
     Length | Signed | Unsigned
     -
     8-bit | i8 | u8
     -
     16-bit | i16 | u16
     -
     32-bit | i32 | u32
     -
     64-bit | i64 | u64
     -
     128-bit | i128 | u128
     -
     arch | isize | usize
     -
     @end
     Signed types can be negative.
     Unsigned $n$-bit types can store values from $0$ to $2^n-1$.
     Signed $n$-bit types can store values from $-2^{n-1}$ to $2^{n-1}-1$.

     The `arch` types have an amount of bits depending on your architecture.
     This is 32 for 32-bit architectures and 64 for 64-bit architectures.

***** Annotate type
      You can annotate the type of the variable like this:
      @code rust
      let x: u32 = 5;
      @end
      You can also put the type at the end of the string literal:
      @code rust
      let x = 5u32;
      @end

***** Integer Literals
      For hex, octal and binary values you can prefix the value with `0x`, `0o` and `0b`.
      You can also put `_` anywhere in your integer literals to make them more readable.

***** Integer Overflow
      If you assign a value to a variable too big for the type of the variable (e.g. 256 to an `u8`) it will overflow.
      If you compile this in debug mode the compiler panics.
      But if you build with the `--release` flag there will be no error.
      The bit at the front will just be ignored: 256 ->  0, 257 -> 1.

**** Floating-Point Types
     There are two floating-point types.
     They are `f32` and `f64` which are 32 and 64 bits big.
     You should use `f64` in most cases because it has nearly the same speed on modern computer but is more precise.
     See also how to {# Annotate type}[annotate the type] and how {# integer literals}[literals] can look like.

**** Numeric Operations 
     Rust supports all the standard operations.
     It's important to notice that integer division always rounds down to the nearest integer.

**** Booleans
     The type for booleans is `bool`.
     They can either be `true` or `false`.

**** Characters
     Characters are specified with single quotes unlike strings which use double quotes.
     They are 4 bytes big and represent an unicode value.

*** Compound types
    Compound types group multiple values into one type.

**** Tuples
     Tuples can group values of different types together.
     Their length can't be changed. They can't grow or shrink.
     You create tuples by putting a comma separated list inside parentheses.
     You can annotate types by putting them inside a tuple:
     @code rust
     let tup: (i32, f64, u8) = (500, 6.4, 1);
     @end

***** Access values
      You can access values inside tuples with so called patterns.
      This looks like this:
      @code rust
      let tup: (i32, f64, u8) = (500, 6.4, 1);
      let (x, y, z) = tup;
      println!("The value of the second element is {}", y);
      @end
      This is called *destructuring*.

      You can also access values by using `.` and the index of the value.
      *Indexing is 0-based*

      @code rust
      let tup = (3,37,12);
      let second = tup.1;
      println!("The second value is {}", second);
      @end

***** Unit Value
      There is also `()` which is a special tuple.
      It's an empty value, like `void` in c. It's called /unit value/.
      Functions without a return value get interpreted as functions with return value `()`.

**** Arrays
     An array groups together multiple values of the *same type*.
     They also have a fixed length.
     Arrays are constructed with a comma separated list of values inside `[]`.
     You can annotate the type of the elements inside the array with a square bracket in which you write the type and the amount of elements inside the array separated with a semicolon like this:
     @code rust
     let arr: [u32; 3] = [1,2,3];
     @end

     You can also initialize an array by providing a default value and a length for the array inside `[]` separated with a semicolon:
     @code rust
     let arr = [3;4];
     // this does exactly the same
     let arr = [3,3,3,3];
     @end

***** Access Values
      You can access a value of an array by putting it's index inside `[]` after the arrays name:
      @code rust
      let arr = [1,2,3,4];
      let second=arr[1]; // second is now 2
      @end

***** Invalid Index
      If you try to access an index out of range you'll get an error.
      Unlike in other languages you can't access memory outside of the array.

** Functions
   You define functions in rust with the `fn` keyword, the function name followed by `()` and curly braces to define the scope of the function.
   Functions can be defined everywhere in the code. It doesn't matter if it's before or after where they're called.

*** Statements
    Statements are pieces of code that don't return a value.
    They *have a semicolon* at the end of them.

*** Expressions
    Expressions do return a value.
    They *don't have semicolons*.
    ---
*** Return Values
    If there is an expression at the end of the function the result of it will be returned.
    You can also return something earlier (and stop the execution of the function) with the `return` keyword.
    If your function returns something you have to annotate the value with an arrow after the function name like this:
    @code rust
    fn my_function() -> u32 {
      3*5
    }
    @end

*** Parameters
    You can pass values to functions with parameters.
    You specify the parameters *and the type* inside the `()` after the function name.
    You can then later use the values inside the function:
    @code rust
    fn adder(x:u32, y:u32) -> u32 {
      x+y
    }
    let x = adder(3,5);
    println!("3 and 5 added equals {}",x);
    @end

** If/Else Statements
   You create if statements with the `if` keyword followed by a condition and `{}`.
   After that you can put an optional `else` and another pairs of curly brackets.
   @code rust
   let number = 3;

   if number < 5 {
     println!("condition was true");
   } else {
     println!("condition was false");
   }
   @end

   The condition *must* be a `bool` (`true` or `false`).

   You can add more conditions with `else if`.
   You can put expressions inside the `if` and `else` blocks and use it as a right side for `let` statements:
   @code rust
   let condition = true;
   let number = if condition { 5 } else { 6 };
   @end
   For this the types of the different values have to be the same.

** Loops
*** Break
    The `break` keyword exits the current loop (if used without a label).
    You can also put an expression after it that will be returned.
    So you could for example do things like this:
    @code rust
    let mut counter = 0;

    let result = loop {
      counter += 1;

      if counter == 10 {
        break counter * 2;
      }
    };
    @end

*** Loop keyword
    You can create loops with the `loop` keyword followed by `{}` where you put the body of the loop.
    This loop will run infinite times. You need to terminate it while executing (`<c-c>`) or with a `break`.
**** Continue
     You can use `continue` to skip all the code remaining in the current iteration and go to the next one.
     ---
    Normally `break` and `continue` apply to the innermost loop at the point.
    You can change that by giving labels to loops.
    You do that like this:
    @code rust
    let mut count = 0;
    'counting_up: loop {
      println!("count = {}", count);
      let mut remaining = 10;

      loop {
        println!("remaining = {}", remaining);
        if remaining == 9 {
          break;
        }
        if count == 2 {
          break 'counting_up;
        }
        remaining -= 1;
      }

      count += 1;
    }
    println!("End count = {}", count);
    @end

*** While Loops
    Use `while`, a condition and `{}` around the body of the loop to create a while loop.
    This loop will repeat as long as the condition is true.
    @code rust
    let x = 1
    while x > 10 {
      println!("X is {}", x);
      x += 1;
    }
    @end

    Notice that `while true` and `loop` do exactly the same.

*** For Loops
    You can iterate through collections with a for loop. It could also be done with a while loop and indexing but it's much more complicated.
    You create a for loop with `for`, a name for each element, a collection and `{}`:
    @code rust
    let a = [10, 20, 30, 40, 50];

    for element in a {
      println!("the value is: {}", element);
    }
    @end

**** Ranges
     You can use a `Range` (provided by stdlib).
     This generates all numbers in a sequence (start-inclusive, end-exclusive).
     You can use the `.rev()` method to reverse the range.
     This can be done like this:
     @code rust
     for number in (1..6).rev() {
       println!("{}", number);
     }
     @end
     This will print 5,4,3,2,1.

** References
   You can use references to variables by putting a `&` in front of their name.
   You do this so they can be accesses in multiple places without copying them into memory multiple times.
   An example for this is for {# input}[input]
   References are also immutable by default.
   If you want to make a mutable one you need to do `&mut <variable>`.

** Error handling
*** Expect
    You can use the `.expect`-method to output a message when the value of the object on which it's called is `Err`.
    Example:
    @code rust
    io::stdin().read_line(&mut input).expect("Failed to read line");
    @end

* Ownership
  Ownership is the way of rust to manage memory. With it rust can make sure that no memory which shouldn't be accessed is accessed.

** Stack and Heap
   They are both parts of the memory which is available to your code at runtime.

**** Stack
     The stack is like a stack of plates.
     You always take things from the top and also add new things to the top (/last in, first out/).
     Therefore you can't really get values from the center.
     Adding values is called /pushing onto the stack/ and removing values is called /popping off the stack/.
     Data on the stack must have a known fixed size.

     Values local to a function and values passed to it are stored on the heap and popped off after the function ends.
     All the data types from {# Scalar Types}[scalar] and {# integer types}[integer] types can be stored on the stack because they have a fixed size.
     Therefore they can be accessed really fast an easily copied if a new independent instance is needed.

**** Heap
     When you store data on the heap you request an amount of space.
     The memory allocator will find a place where there is enough space, marks it as being used and returns a pointer to it.
     This is called /allocating on the heap/.
     The pointer has a know, fixed size.
     Therefore you can store it on the stack.
     ---
   Because the memory allocator has to find a space, return a pointer etc. it's slower to store things on the heap.
   Accessing data on the heap is also slower because the computer has to read the pointer, go to that location and retrieve the data.

   Ownership addresses the problems of keeping track of data on the heap, minimizing duplicate data und cleaning up unused data.

** Ownership Rules
   There are three ownership rules:
   - Each value in Rust has a variable that’s called its /owner/.
   - There can only be one owner at a time.
   - When the owner goes out of scope, the value will be dropped.

** Variable Scopes
   Variables are only valid inside their scope.
   Scopes are often delimited with `{}`.
   ---

  Values of the {# String type}[`String`] type need to allocate memory on the heap.
  For this memory needs to be requested from the memory allocator at runtime and memory needs to be returned to the allocator when the `String` value is no longer needed.
  The first action is done when we do `String::from`.
  In many languages the second action is done by a /garbage collector/.
  In languages without a GC we need to do this ourself.
  This leads to many problems:
  - We wast memory if we forget it
  - We have an invalid variable if we do it too early
  - We get an error if we do it twice
    In Rust the memory is automatically freed if a variable gets out of scope.
    Rust uses the `drop` function which does free memory.
    You can also use this function yourself but there are only a few cases where you need to do so.

** Moving
   If you assign values from the heap to a new variable it will get /moved/.
   @code rust
   let x = String::from("test");
   let y = x;
   @end
   When you do that with data types which are stored on the heap there will just a pointer, a length and a capacity which are getting copied into the new variable.
   Since that would lead to problems because the memory would be freed two times the old variable (`x`) is now invalid.
   So this is basically just a renaming of the variable.

** Clone
   If you really want a copy of a `String` then you can use the `clone` method:
   @code rust
   let x = String::from("test");
   let y = x.clone();
   @end

   Now both `x` and `y` are valid variables.
   This just is really expensive in terms of memory.

** Copy
   Data which is only stored on the stack just gets copied.
   That means after this:
   @code rust
   let x = 5;
   let y = x;
   @end
   Both `x` and `y` are valid.
   This is done because it's really fast to create new data on the stack and they have a known size at compile time.

   If a type which is stored on the stack has the `Copy` trait it will be copied and therefor the first variable will still be valid after the assignment.
   Values which implement the `Copy` trait:
   - Integer types (e.g. `u32`)
   - Boolean type `bool`
   - Floating point types (e.g. `f64`)
   - Character type `char`
   - Tuples if they only contain types that implement `Copy`

** Functions
   If you pass values as parameters into functions then they will be copied or moved.
   So if you pass a value which doesn't have a `Copy` trait you can't use it after you passed it to the functions reference.
   If you want to do so you can either copy it or pass a reference.

   If you return a value from a function it gets moved/copied into the value to which the return value is assigned.

** References
   You can pass a reference to a value to a functions instead of the value itself.
   Then the value won't be used an you can still use the variable after the function call.
   The difference between a reference and a pointer is that the reference is guaranteed to point to a valid value of a particular type.
   You pass a reference by putting a `&` in front of the variable name in the function call and you also put a `&` before the type in the annotations.
   @code rust
   fn main() {
     let s1 = String::from("hello");

     let len = calculate_length(&s1);

     println!("The length of '{}' is {}.", s1, len);
   }

   fn calculate_length(s: &String) -> usize {
     s.len()
   }
   @end

   `&si` references to `s1` here but it does not own it.
   Because of that `s1` won't be dropped when `s` is no longer used.

   This action of taking a reference and using it is called *borrowing*.

*** Mutable References
    References are just like variables immutable by default.
    You can make the mutable like this:
    @code rust
    fn main() {
      let mut s = String::from("hello");

      change(&mut s);
    }

    fn change(some_string: &mut String) {
      some_string.push_str(", world");
    }
    @end

    You can have only one mutable reference (doesn't matter if second one is mutable or not) for a variable simultaneously.
    That means you can have multiple references like this:
    @code rust
    let mut s = String::from("hello");
    {
      let r1 = &mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &mut s;
    @end
    ---
| reference rules
   - At any time you can only have *either* one mutable reference *or* any number of immutable references.
   - References must be valid.

** Slice Type
   A slice lets you reference a sequence in a collection.

*** String slices
    You can create slices of strings with `[start_idx..end_idx]`:
    @code rust
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];
    @end
    This gets stored with a pointer to the start position and a `len` value.
    String slices have the type `&str`.
    If you want to start at the first element you don't have to write the `0`.
    So `&s[0..5]` and `&s[..5]` are the same.
    The same is the case for the last index.
    You can also just use `..` to specify the whole string.

**** String Literals
     String Literals are just slices.
     They reference something which is stored somewhere in the binary.
     They have the type `&str`. This is also why they are immutable.
     They are immutable string references.

*** Other slices
    You can also refer to parts of arrays like this:
    @code rust
    let a = [1, 2, 3, 4, 5];

    let slice = &a[1..3];
    @end
    The type of this would be `&[i32]`.

* Structs
  /Structures/ known as /structs/ are like custom types.
  You can use them to group together related values.
  You can also associate functions with the values.
  Structs are similar to {# tuples}[tuples].
  The difference is that you can name the values so you don't have to care about the order and the code is more readable.

** Defining Structs
   You can define structs with the `struct` keyword followed by the name and `{}` inside which you define the /fields/ of the struct.
   @code rust
   struct User {
     active: bool,
     username: String,
     email: String,
     sign_in_count: u64,
   }
   @end

** Creating instances of structs
   You can create an instance for a struct like this: (example from above used)
   @code rust
   let user1 = User {
     email: String::from("someone@example.com"),
     username: String::from("someusername123"),
     active: true,
     sign_in_count: 1,
   };
   @end
   You can access values with `.` and the field name:
   @code rust
   println!("User1's email is {}",user1.email)
   @end

   If the instance is mutable (`let mut user1 = User ...`) you can also change values like this.

** Field init shorthand
   If you have a variable that has the same name as a field you can use a shorthand to create an instance.
   Here you can also see how you annotate functions that return an instance of a struct.
   @code rust
   fn build_user(email: String, username: String) -> User {
     User {
       email, // instead of email: email
       username, // instead of username: username
       active: true,
       sign_in_count: 1,
     }
   }
   @end

** Struct update syntax
   You can use the `..` syntax to just extend an existing struct with new fields:
   @code rust
   let user2 = User {
     email: String::from("another@example.com"),
     ..user1
   };
   @end
   This will set all fields which aren't specified to the values which they have in `user1`.
   In this example you could no longer use `user1` because the `username` `String` value is moved.

** Tuple Structs
   You can also create structs which are like tuples and have unnamed fields.
   The difference between them and tuples is that they have their own type for all instances.
   @code rust
   struct Color(i32, i32, i32);
   struct Point(i32, i32, i32);

   fn main() {
     let black = Color(0, 0, 0);
     let origin = Point(0, 0, 0);
   }
   @end
   You can access the values inside them like the values of {# Access values}[tuples].

** Printing instances
   You can use `{:\?}` as placeholder inside `println!` to use an output format called `debug`.
   By default this won't work though.
   You need to add `#[derive(Debug)]` before your definition of the struct.
   You can also use `{:\#}` to make the output prettier.
   @code rust
   #[derive(Debug)]
   struct Rectangle {
     width: u32,
     height: u32,
   }

   fn main() {
     let rect1 = Rectangle {
       width: 30,
       height: 50,
     };

     println!("rect1 is {:?}", rect1);
   }
   @end

   This will output `rect1 is Rectangle { width: 30, height: 50 }`.

** Methods
   To define a method for a struct we start and implementation (`impl`) block.
   You can use `&self` as the first parameter and later use it in the function to access values of the instance on which the method is used.
   You can then use this method with a `.` and the method name.
   @code rust
   struct Rectangle {
     width: u32,
     height: u32,
   }

   impl Rectangle {
     fn area(&self) -> u32 {
       self.width * self.height
     }
   }

   fn main() {
     let rect1 = Rectangle {
       width: 30,
       height: 50,
     };

     println!(
       "The area of the rectangle is {} square pixels.",
       rect1.area()
     );
   }
   @end

** Associated functions
   You can have functions inside an `impl` block without a `self` parameter.
   Those functions you can access with `<struct_name>::<function_name>()`.
   @code rust
   impl Rectangle {
     fn square(size: u32) -> Rectangle {
       Rectangle {
         width: size,
         height: size,
       }
     }
   }
   let sq = Rectangle::square(5);
   @end

* Enums
  *Enumerations* or *enums* allow you to define a type by enumerating its possible *variants*.

** Defining an Enum
   You define enums with the `enum` keyword, the name, a pair of curly braces and the possible values.
   @code rust
   enum IpAddrKind {
     V4,
     V6,
   }
   @end

** Enum Values
   You create instances of the variants with the enum name, `::` and one of the possible values.
   @code rust
   let four = IpAddrKind::V4;
   @end
   This value does have the type `IpAddrKind`.
   With this you can for example use it in function signatures.
   @code rust
   fn rout(ip_kind: IpAddrKind) {}
   @end

   You can then call this function like with `route(IpAddrKind::{V4,V6})`.

*** Data
    You can add data to possible enum values in two ways.

**** Tuple data
     Data can be added in a format like tuples like this:
     @code rust
     enum IpAddr {
       V4(u8, u8, u8, u8),
       V6(String),
     }

     let home = IpAddr::V4(127, 0, 0, 1);
     let loopback = IpAddr::V6(String::from("::1"));

     @end
     You could also put structs inside the `()`.

**** Struct like data
     You can also add data with names fields like struct in the following way:
     @code rust
     enum Message {
       Move { x: i32, y: i32},
       Write(String),
       ChangeColor(i32, i32, i32),
     }
     @end
     ---
    You could also create similar data strucutres with structs.
    The difference is that here all of them (`Move`,`Name`,`Color`) have the same type so you can pass them to the same function.

*** Methods
    You can also define methods for enums just like for structs:
    @code rust
    impl Message {
      fn call(&self) {
        // do things here
      }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
    @end

** Option enum
   The `Option` type enum is defined by the standard library.
   It's used in a case where a value can be something or nothing.
   Rust doesn't have a `null` value that means that there is no value (like `nil` in lua).
   Rust has an enum that represents the concept of a value being present or absent: `Option<T>`.

   The `Option<T>` enum is defined like this:
   @code rust
   enum Option<T> {
     None,
     Some(T),
   }
   @end
   This enum is in the scope by default.
   So you don't have to use `Option::` to access the values.
   You can directly use `None` and `Somet(T)` which are values with the type `Option<T>`.

   `<T>` is a generic type.
   That means that the `T` in `Some(T)` can hold a value of every type and that each concrete type that gets used in `T` makes the `Option<T>` a different type.
   @code rust
   let some_number = Some(5);
   let some_string = Some("a string");

   let absent_number: Option<i32> = None;
   @end
   Here the type of `some_number` is `Option<i32>`, the one of `some_string` `Option<&str>`.
   If you assign something a `None` value you need to annotate the type because the compiler can't guess the type of the `Some` value.

*** Why Option enum
    If you have `let number=Some(5)` then the type of `number` is `Option<i32>`.
    The compiler doesn't allow you to use this number like it was type `i32` and definitely a valid value.
    For example this wouldn't work:
    @code rust
    let x: i8 = 5;
    let y: Option<i8> = Some(5);

    let sum = x + y;
    @end

    So if you want to create a value that can be null you have to use `Option<T>` and then also explicitly handle the case when it's null.
    If the type isn't `Option<T>` you can be sure that the value isn't null.
    ---

** `match` Control Flow Construct
   With this control flow construct you can compare values against some patterns and execute code based on which pattern is matched.
   The code for the first pattern that matches gets execucted.

*** Creating match statements
    You create a `match` statement with the `match` keyword, an expression and `{}`.
    This looks like an {# If/Else Statements}[`if` statement].
    The difference is that in an `if` statement the expression needs to return a boolean value.
    Here the expression can return any type.
    Inside the `{}` there are so called /`match` arms/.

**** Match arms
     Each match arm consists of three parts:
     ~ A pattern
     ~ `=>`
     ~ Code to execute

     Each arm is separated from the other ones with a comma.
     The result of the expression that gets executed in an arm is the result of the whole `match` statement.
     You can (if the code is multiple lines you must) use `{}` around the code.
     ---
    @code rust
    enum Coin {
      Penny,
      Nickel,
      Dime,
      Quarter,
    }
    fn value_in_cents(coin: Coin) -> u8 {
      match coin {
        Coin::Penny => {
          println!("Lucky penny!");
          1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
      }
    }
    @end

*** Patterns that bind to values
    We can change the example to include a state for quarters.
    You could do this and then print out the state like this:
    @code rust
    #[derive(Debug)] // so you can print out the code
    enum UsState {
      Alabama,
      Alaska,
      // ...
    }

    enum Coin {
      Penny,
      Nickel,
      Dime,
      Quarter(UsState),
    }
    fn value_in_cents(coin: Coin) -> u8 {
      match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
          println!("State quarter from {:?}!", state);
          25
        }
      }
    }
    @end

*** Matching with `Option<T>`
    You can match with `Option<T>` and for example change values like this:
    @code rust
    fn plus_one(x: Option<i32>) -> Option<i32> {
      match x {
        None => None,
        Some(i) => Some(i + 1),
      }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
    @end

*** Exhaustive Matches
    If you have this function in the above example:
    @code rust
    fn plus_one(x: Option<i32>) -> Option<i32> {
      match x {
        Some(i) => Some(i + 1),
      }
    }
    @end
    The code won't compile.
    This is because matches are *exhaustive*. All cases need to be handled.
    For example if you have a game where a player dies when he rolls a 1, goes 3 steps back when he rolls a 6 and otherwise moves the number of fields he rolled forward.
    You could do that like this:
    @code rust
    let dice_roll = 5;
    match dice_roll {
      1 => die(),
      6 => go_back(3),
      other => move_player(other),
    }

    fn die() {}
    fn go_back(num_spaces: u8) {}
    fn move_player(num_spaces: u8) {}
    @end
    Other can be any valid variable name.
    It will match everything not matched before.
    It's just used to be able to use the value in the code that gets executed.

    If you won't use the matched value you can just use `_`.
    This shows the compiler that you don't plan to use the variable and therefore it won't give an error "unused variable".
    If you want to do nothing you can use the {# unit value}:
    @code rust
    match dice_roll {
      1 => add_fancy_hat(),
      6 => remove_fancy_hat(),
      _ => (),
    }
    @end

** If let statements
   They are a like a wrapper around {# `match` Control Flow Construct}[`match` statements].
   Those are equal:
   @code rust
   let config_max = Some(3u8);
   match config_max {
     Some(max) => println!("The maximum is configured to be {}", max),
     _ => (),
   }
   @end

   @code rust
   let config_max = Some(3u8);
   if let Some(max) = config_max {
     println!("The maximum is configured to be {}", max);
   }
   @end
   They are useful so you don't have to add a lot of boilerplate code.

* Packages, Crates and Modules
  - *Packages*: A Cargo feature that lets you build, test, and share crates
  - *Crates*: A tree of modules that produces a library or executable
  - *Modules* and use: Let you control the organization, scope, and privacy of paths
  - *Paths*: A way of naming an item, such as a struct, function, or module

**  Packages and Crates
    Creates can either be a binary or a library.
    The /crate root/ is a file from which the compiler starts and which makes up the root module of the crate.
    A package is one or more crates that provide a set of functionality.
    Each package contains a /Cargo.toml/ file that explains how to build the crates.
    There are some rules for what a crate can contain:
    - At least 1 crate
    - At most one library crate
    - As many binary crates as wanted

    You can create a new package with `Cargo new`.
    This will create a /src/main.rs/ and a /Cargo.toml/
    The /src/main.rs/ file is for cargo the root of a binary crate with the same name as the package.
    If there is a /src/lib.rs/ file it's a library crate with the same name as the package with /src/lib.rs/ as crate root.
    If a package has a /src/main.rs/ and a /src/lib.rs/ file is contains both a library and a binary crate with the same name as the package.
    You can have a package with multiple binary crates by placing files inside /src/bin/.
    Each of the files will be it's own binary crate.

    A create groups together related functionality in a scope so you can use it easily in other places.

** Modules
   Here is a quick summary for modules:
   - *Start from the crate root*:
     When compiling a crate, the compiler first looks in the crate root file (usually /src/lib.rs/ for a library crate or /src/main.rs/ for a binary crate).
   - *Declaring modules*:
     In the crate root file, you can declare a new module named, say, “garden”, with `mod garden;`.
     The compiler will look for the code inside the module in these places:
   -- Inline, directly following `mod garden`, within curly brackets instead of the semicolon
   -- In the file /src/garden.rs/
   -- In the file /src/garden/mod.rs/
   - *Declaring submodules*:
     In any file other than the crate root that’s being compiled as part of the crate (for example, /src/garden.rs/), you can declare submodules (for example, `mod vegetables;`).
     The compiler will look for the code inside submodules in these places within a directory named for the parent module:
   -- Inline, directly following `mod vegetables`, within curly brackets instead of the semicolon
   -- In the file /src/garden/vegetables.rs/
   -- In the file /src/garden/vegetables/mod.rs/
   - *Paths to code in modules*:
     Once a module is being compiled as part of your crate, you can refer to code in that module (for example, an `Asparagus` type in the garden vegetables module) from anywhere else in this crate by using the path `crate::garden::vegetables::Asparagus` as long as the privacy rules allow.
   - *Private vs public*:
     Code within a module is private from its parent modules by default.
     To make a module public, declare it with `pub mod` instead of `mod`.
     To make items within a public module public as well, use `pub` before their declarations.
   - *The `use` keyword*:
     Within a scope, the `use` keyword creates shortcuts to items to reduce repetition of long paths.
     In any scope that can refer to `crate::garden::vegetables::Asparagus`, you can create a shortcut with `use crate::garden::vegetables::Asparagus;` and then only need to write `Asparagus` to make use of that type in the scope.

   This would be the file structure for these examples:
   @code
   backyard
    ├── Cargo.lock
    ├── Cargo.toml
    └── src
        ├── garden
        │   └── vegetables.rs
        ├── garden.rs
        └── main.rs
   @end

*** Paths to refer items in the module tree
    You can use absolute or relative paths:
    - Absolute paths start from the crate root by using the crate name or `crate` for the current crate.
    - Relative paths start from the current module.

    So (using the example from above) you could do something like this in /src/main.rs/:
    @code rust
    // Make sure to make the module, submodules and items public if you want to use them
    // By default everything is private
    pub mod garden;

    fn test() {
      // Absolute path
      let x=crate::garden::vegetables::Asparagus;

      // Relative path
      let x = garden::vegetables::Asparagus;
      x
    }
    @end

    You should decide whether to use an absolute or a relative path based on whether you think you'll move only the usage or the definition of the code or both together.

    You can also start relative paths with `super`. This is like using `..` in a file system path.

*** Public enums and structs
    You can make {# structs} and {# enums} public.
    For struct you have to make sure to also make all the fields you want to use public as well.
    Be default all fields all private.
    For enums you only have to use the `pub` keyword before the `enum` keyword.

*** Using `use` to bring modules into scope
    You can use e.g. `use crate::garden::vegetables;` to bring `vegetables` into scope.
    Later you can then use `vegetables::Asparagus` without providing the whole path.
    This works with absolute and relative paths.

    Normally use bring enums and struct directly into scope by providing the full path.
    For other things like functions you don't do that so you can see where the function was defined.
    This also avoids name conflicts.

**** Aliases with `as`
     You can also avoid the name collisions by using an alias.
     You could for example do this:
     @code rust
     use std::fmt::Result;
     use std::io::Result as IoResult;
     @end

**** Re-exporting
     If you use `use` the name in the new scope is private.
     You can use `pub use` to make it available.
     This is called re-exporting.

**** External packages
     You can use external packages by putting them into your `Cargo.toml` with something like this:
     @code toml
     [dependencies]
     rand = "0.8.4"
     @end
     You can then use this in your code with e.g. `use rand::Rng` to use the `Rng` trait.
     You need to do this for some functions of certain crates.
     Sometimes you don't have to.

**** Using nested paths
     You can use `{}` to use multiple modules of the same crate like this:
     @code rust
     // normal
     use std::cmp::Ordering;
     use std::io;

     // nested paths
     use std::{cmp::Ordering, io};
     @end

     You can do the same for `use` statements that share a subpath with `use std::io::{self, Write};`.
     This will bring `std::io` and `std::io::Write` into scope.

**** Glob operator
     You can use the glob operator `*` to bring all defined in a path into scope like this:
     @code rust
     use std::collections::*;
     @end

* Collections
  Collections are a way to store values.
  Unlike {# tuples} and {# arrays} they are stored on the heap.
  Because of that the size doesn't need to be known on compile time.
** Vectors
   Vectors have the type `Vec<T>` where `T` is the type of the values.
   They can store values of the same type.

*** Creating a new vector
    You create a new vector with the `Vec::new()` function like this:
    @code rust
    let v: Vec<i32> = Vec::new();
    @end
    In this case you need to add a type annotation because you don't insert any values into the vector. 

    You can also create a vector with initial values.
    You do that with the `vec!` macro:
    @code rust
    let v = vec![1, 2, 3];
    @end
    This vector will have the type `Vec<i32>` because `i32` is the default type for integers.

*** Updating a vector
    To be able to modify a vector you need to make it mutable ({# Mutability})
    You can add new values to a vector with the `push` method like this:
    @code rust
    let mut v = Vec::new(); // no annotation needed since `i32` values are pushed
    v.push(5);
    v.push(9);
    @end

    You can remove and return the last value of a vector with the `pop` method.

*** Dropping a vector
    If a vector gets dropped (goes out of scope) all it's values will be cleaned up.

*** Reading vectors
    There are two ways to read the values of a vector:
    - indexing
    - use the `get` method

    @code rust
    let v = vec![1, 2, 3, 4, 5];

    let third: &i32 = &v[2]; // zero based indexing
    println!("The third element is {}", third);

    match v.get(2) {
      Some(third) => println!("The third element is {}", third),
      None => println!("There is no third element."),
    }
    @end

    As you can see indexing `&` and `[]` gives a reference.
    Using `get` gives an `Option<&T>`.

**** Differences
     The difference between the two methods is how they react when the element isn't accessible.
     When you try to index a value that doesn't exist the program panics and stops.
     But when you use `.get` it just returns `None`.
     So you'd use the `get` method if it's possible that a value isn't present *under normal circumstances*.
     Your code will then have the logic to handle the `None` case ({# option enum}).
     ---
    You have to remember that you can't have an immutable and a mutable reference together ({# reference rules}).
    When you `push` to a vector a mutable borrow occurs.
    This is because the values in a vector are next to each other in memory and may have to be moved when there is no memory left next to the other values.
    So this code
    @code rust
    let mut v = vec![1, 2, 3, 4, 5];

    let first = &v[0];

    v.push(6);

    println!("The first element is: {}", first);
    @end
    ... would lead to this error:
    @code
    error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
     --> src/main.rs:6:5
      |
    4 |     let first = &v[0];
      |                  - immutable borrow occurs here
    5 | 
    6 |     v.push(6);
      |     ^^^^^^^^^ mutable borrow occurs here
    7 | 
    8 |     println!("The first element is: {}", first);
      |                                          ----- immutable borrow later used here
    @end

*** Iterating over values of vectors
    You can iterate over a vector like this:
    @code rust
    let v = vec![10, 20, 30];
    for i in &v {
      println!("{}",i);
    }
    @end

    You can also iterate with mutable references.
    For example to add 50 to every value.
    @code rust
    let mut v = vec![100, 32, 57];
    for i in &mut v {
      *i += 50; // `*` for dereferencing -> value is needed to add 50 to it not just pointer
    }
    @end

*** Store multiple types with enums
    You sometimes want to store values of different types together but vectors only allow you to store values of one type.
    You can use {# enums} to do that for example like this:
    @code rust
    enum SpreadsheetCell {
      Int(i32),
      Float(f64),
      Text(String),
    }

    let row = vec![
      SpreadsheetCell::Int(3),
      SpreadsheetCell::Text(String::from("blue")),
      SpreadsheetCell::Float(10.12),
    ];
    @end

*** Other methods/functions
    Some useful methods which you can use on vectors: (`vec` is a variable with a value of the type `Vec<T>`)
    - `vec.len()`: Gets the amount of values in the vector
    - `vec.remove(<index>)`: Removes element and returns it
    - `Vec::with_capacity(<capacity>)`: With this you can create a vector with the specified size.
      Then there will be that amount of space allocated.
      This is useful to avoid that the vector needs more space, new memory needs to be allocated and the values need to be copied which could be quite slow.
    - `vec.shrink_to_fit()`: This shrinks the capacity of the vector as much as possible.
    - `vec.capacity()`: Checks how much elements the vector can hold without reallocating.
    @code rust
    let vec: Vec<i32> = Vec::with_capacity(10);
    assert_eq!(vec.capacity(), 10);
    @end
    - `vec.append(<other>)`: Moves all elements from `<other>` into `vec` leaving `<other>` empty.
    @code rust
    let mut vec = vec![1, 2, 3];
    let mut vec2 = vec![4, 5, 6];
    vec.append(&mut vec2);
    assert_eq!(vec, [1, 2, 3, 4, 5, 6]);
    assert_eq!(vec2, []);
    @end


** String type
*** String literals
    You can use string literals to assign string values to variables.
    Rust knows all the string literals at compile time (not only the ones from "initial assignments").
    So you can't change the strings but only the value of to variable to another string literal.
    They are fast and efficient because their values are hardcoded into the executable.
    But that doesn't work for things which you don't know the size of.
    ---
   String literals are limited in some cases.
   That's because they are immutable.
   Also for some string values you don't know their value at compile time (e.g. user input).
   That's why there is the `String` type.

*** Creating a `String` value
    You can also use `String::new()` to create a new empty string.
    You can use `String::from` to create a new `String` type value from a string literal.
    @code rust
    let s = String::new();
    let s2 = String::from("string");
    @end

    Last but not least you can use the `to_string` method on every value that implements the `Display` trait.
    This is for example the case for the number types and string literals.

*** Modifying a String
**** Appending
     An example for modification is the `.push_str` method which you can use on the variable to append a string literal to the string.
     Notice that for this the string needs to be mutable.
     @code rust
     let mut s = String::from("hello");
     s.push_str(", world!"); // push_str() appends a literal to a String
     println!("{}", s); // This will print `hello, world!`
     @end
     The `push_str` method does not take ownership of the values passed into it.
     So something like this is no problem:
     @code rust
     let mut s1 = String::from("foo");
     let s2 = "bar";
     s1.push_str(s2);
     println!("s2 is {}", s2);
     @end

     There is also the `push` method which takes a single character as parameter.
     @code rust
     let mut s = String::from("lo");
     s.push('l'); // contains now `lol`
     @end

**** Concatenation
     There are two ways to concatenate two string.

***** `+` operator
      You can use the `+` operator like this:
      @code rust
      let s1 = String::from("Hello, ");
      let s2 = String::from("world!");
      let s3 = s1 + &s2; // notice that `&s2` is a reference
      @end
      After this `s1` can no longer be used.
      The reason for that and also the reason why you have to use a reference for `s2` is the signature of the `add` method which is used by the `+` operator.
      This signature looks something like this:
      @code rust
      fn add(self, s: &str) -> String {
      @end
      The compiler can convert the `&String` type to a `&str`.
      As you can see `add` does not take ownership of the parameter.
      So you'll still be able to use `s2` after the concatenation.
      The function takes ownership of `self` though.
      So `s1` is moved into the `add` call and will no longer be valid after it.

      The `+` operator (`add`) actually takes ownership of the first value, appends a copy of the contents of the second value and returns ownership of the result.
      You could also do that with more than two strings:
      @code rust
      let s1 = String::from("tic");
      let s2 = String::from("tac");
      let s3 = String::from("toe");

      let s = s1 + "-" + &s2 + "-" + &s3;
      @end
      But since that is getting quite complicated with all the `+` and `"` you should rather use the `format!` macro.

***** `format!` macro
      The format macro is similar to {# printing}[`println!`].
      But instead of printing the value to the screen it returns a `String` value with the contents.
      It also uses references so it doesn't take ownership of any of the values.
      The example from above could be rewritten like this:
      @code rust
      let s1 = String::from("tic");
      let s2 = String::from("tac");
      let s3 = String::from("toe");

      let s = format!("{}-{}-{}", s1, s2, s3);
      @end

*** Indexing into Strings
    Rust does not support indexing of strings like this:
    @code rust
    let s1 = String::from("hello");
    let h = s1[0];
    @end
    The reason for that is actually quite simple.
    Strings get stored as `Vec<u8>`.
    The problem is that not every single UTF-8 character (e.g. Cyrillic letters) is one byte long.
    So if you'd store `"Здравствуйте"` in a string and then get the first element with `[0]` you'd get the first byte which would be `208`.
    But users don't want to get a number but a single letter.
    To avoid misunderstandings like this rust doesn't compile the code.

    Another reason is that operation are expected to take constant time (`O(1)`).
    This isn't possible since Rust would have to go through the contents from the beginning to the index to check how many valid characters there are.

*** Slicing Strings
    It's already described how to slice string in {# slice type}.
    The indices for string slices are bytes.
    Rust will give you an error if you try to slice in the center of a multi-byte character.

*** Iterating over strings
    There are two methods to create iterables for strings.

    You can use `.chars()` to iterate over the characters of strings (works with multi-byte characters).

    You can also use `.bytes()`.
    With this you can get all the bytes of the string as numbers.

** Hash maps
   The type `HashMap<K, V>` stores a mapping of keys of type K to values of type V using a *hashing function*, which determines how it places these keys and values into memory.
   They are useful if you want to look up data with a key of any type and not an index like vectors.
   All of the keys and all of the values in one hash map have to be of the same type though.
   Hash maps aren't in scope by default. You need to bring it into scope like this:
   @code rust
   use std::collections::HashMap;
   @end

*** Creating a new hash map
    You can create a new empty hash map with `HashMap::new()`.
    Then you can insert values into it with the `.insert()` method.
    This method takes two arguments where the first is a key and the second a value.
    @code rust
    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from("Blue"),10);
    scores.insert(String::from("Yellow"),50);
    @end

    Another way to create hash maps is by using iterators and the `collect` method on a vector of tuples where each tuple consists of a key and it's value.
    You use the `zip` method to combine two iterables into pairs of tuples.
    You can then use `collect` to turn the iterator of tuples into a has map.
    @code rust
    use std::collections::HashMap;

    let teams = vec![String::from("Blue"), String::from("Yellow")];
    let initial_scores = vec![10, 50];

    // type annotation needed because `collect` can use many different type
    // using `_` because the type can be determined by the types in the vectors
    let mut scores: HashMap<_, _> = teams.into_iter().zip(initial_scores.into_iter()).collect();
    @end

*** Ownership
    Values that implement the `Copy` trait are copied into the hash map.
    Owned values (e.g. `String`) are moved and the hash map will be the owner of them (see {# ownership rules}).

    If you use references in a has map the values that the references point to must be valid for at least as long as the hash map is valid.

*** Accessing values
    You can use the `get()` method which takes a key as argument to get the associated value.
    @code rust
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    let team_name = String::from("Blue");
    let score = scores.get(&team_name);
    @end
    The type of `score` is now `Some(&10)`.
    It could also be `None` if there is no value for that key.
    This is because `get` uses the {# option enum}.

**** Iterating over key, value pairs
     @code rust
     use std::collections::HashMap;

     let mut scores = HashMap::new();

     scores.insert(String::from("Blue"), 10);
     scores.insert(String::from("Yellow"), 50);

     for (key, value) in &scores {
       println!("{}: {}", key, value);
     }
     @end

*** Update values
    There are three ways you can handle the case when there already is a value for a key you want to use:
    - Replace the old value with the new one (disregarding old value)
    - Keep old value and ignore new one
    - Combine the old and the new value

**** Overwriting a value
     You can overwrite a value by just calling `insert` again with the same key.
     @code rust
     use std::collections::HashMap;

     let mut scores = HashMap::new();

     scores.insert(String::from("Blue"), 10);
     scores.insert(String::from("Blue"), 25);

     println!("{:?}", scores); // prints `{"Blue": 25}`
     @end

**** Only insert if the key has no value
     You can use the `entry` method which checks if there is an entry for the value and `or_insert` which inserts a value if there is none to do this.
     The `or_entry` method returns a mutable reference to the value.
     @code rust
     use std::collections::HashMap;

     let mut scores = HashMap::new();
     scores.insert(String::from("Blue"), 10);

     scores.entry(String::from("Yellow")).or_insert(50);
     scores.entry(String::from("Blue")).or_insert(50);

     println!("{:?}", scores); // prints `{"Yellow": 50, "Blue": 10}`
     @end

**** Insert value depending on old value
     For this we use the mutable reference that gets returned by `or_insert`.
     @code rust
     use std::collections::HashMap;

     let text = "hello world wonderful world";

     let mut map = HashMap::new();

     for word in text.split_whitespace() {
       let count = map.entry(word).or_insert(0);
       *count += 1;
     }

     println!("{:?}", map);
     @end
     This code would count the occurrences of each word in the string.

* Error Handling
  Rust has two types of errors: *recoverable* and *unrecoverable* errors.
  For a recoverable error, such as a `file not found` error, we most likely just want to report the problem to the user and retry the operation.
  Unrecoverable errors are always symptoms of bugs, like trying to access a location beyond the end of an array, and so we want to immediately stop the program.

  Rust uses the type `Results<T, E>` for recoverable errors and the `panic!` macro for unrecoverable errors.

** Unrecoverable errors and `panic!`

* Useful things
** Local documentation
   You can access documentation with `rustup doc` in the terminal.
   The Rust book is accessible with `rustup doc --book`.
   You can view the documentation of your current project with `cargo doc --open`.

** Random number
   You can generate random numbers with the `rand` crate.
   The code to get a random number from 1 (inclusive) to 101 (exclusive) looks like this:
   @code rust
   use rand::Rng;
   let number = rand::thread_rng().gen_range(1..101);
   @end

* Crates and Modules
  You can find crates on {https://crates.io/crates/rand}[crates.io]
** Std
*** Io
    Use the `io` module of the `std` library for input/output.
**** Input
     You can get input with `io::stdin()` and then calling the `read_line` method on it.
     This looks like that:
     @code rust
     io::stdin()
     .read_line(&mut <string_variable>) // needs to be mutable
     @end

* Cargo
  Cargo is a build system and dependency manager for rust.
  It comes builtin with rustup.
** New project
   You can start a new project with `cargo new <project_name>`.
   This will create a directory `<project_name>`.
   Inside this there will be a `cargo.toml`, a `.gitignore` and a /src/main.rs/ file in which there will be a "Hello World!" program.
** Config
   You place the config for cargo in a `cargo.toml` file at the root of your project.
   There you specify metadata about your project and dependencies.
** Commands
*** Build
    You can build projects with `cargo build`.
    This will compile the code and place an executable inside `target/debug/`.
**** Release
     You can use the `--release` flag to compile a release.
     For a release binary the code will be optimized so it will run faster. Because of that it takes longer to compile it.
     ---
    So if you compile your binary often (e.g. for testing) you shouldn't use the `release` flag.
    But if you run it often and only compile it once it is worth the time it takes to compile with the `release` flag.

*** Run
    You can build an run your code in one step with `cargo run`.

*** Check
    With `cargo check` cargo just checks if your code would compile but doesn't compile it.
    This is useful for quick tests while coding.
